package temporary

import (
	"fmt"
	"os"
	"reflect"
)

func (temp *Temp) init(inter interface{}) {
	temp.generateCode(inter)
}

func (temp *Temp) generateCode(param interface{}) {

	var pkgPath string
	var depType string

	if param == nil {
		depType = "interface{}"
	}

	t := reflect.TypeOf(param)
	depType = fmt.Sprintf("%s", t)

	temp.dependencyName = depType

	if t.Kind() == reflect.Ptr {
		pkgPath = t.Elem().PkgPath()
	} else {
		pkgPath = t.PkgPath()
	}

	tempCode := getTempCodeStr(pkgPath, depType)

	err := os.WriteFile("./temporary/temp.go", []byte(tempCode), 0644)

	if err != nil {
		panic(err)
	}

	runCode := getRunCode(depType, pkgPath)

	err = os.WriteFile("./temporary/run2.go", []byte(runCode), 0644)

	if err != nil {
		panic(err)
	}
}

func getTempCodeStr(pkgPath string, varType string) string {

	pkgImpt := fmt.Sprintf(
		`			
// Code generated by Temporary; DO NOT EDIT.

package temporary

import "%s"
		`, pkgPath)

	temp := fmt.Sprintf(
		`
// TEMPORARY STRUCT
type Temp struct {
	dependency %s
	dependencyName string
}
`, varType)

	newTemp := fmt.Sprintf(
		`		
// POINTER TO STRUCT
func NewTemp(dep interface{}) *Temp {
	t := &Temp{dependency: dep.(%s)}
	t.init(dep)
	return t
}
`, varType)

	return fmt.Sprintf("%s\n%s\n%s", pkgImpt, temp, newTemp)

}

func getRunCode(depType string, pkgPath string) string {
	snip1 := getPackageAndImportsStr(pkgPath)
	snip2 := getPartialPageBoostFnStr(depType)
	snip3 := getDynamicPageClosureStr(depType)
	snip4 := getStaticPageClosureStr(depType)
	snip5 := getDyamicRouteClosureStr(depType)
	snip6 := getStaticRouteClosureStr(depType)
	snip7 := getStaticFullPageClosureStr(depType)
	snip8 := getDynamicFullPageClosureStr(depType)
	snip9 := getUserFunctionWrapperStr(depType)
	snip10 := executeAppropriateFnStr(depType)

	return fmt.Sprintf("%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n", snip1, snip2, snip3, snip4, snip5, snip6, snip7, snip8, snip9, snip10)
}

func getPackageAndImportsStr(pkgPath string) string {
	return fmt.Sprintf(`
package temporary

import (
	"bytes"
	"errors"
	"fmt"
	"html/template"
	"net/http"
	"path/filepath"

	"%s"
	"github.com/a-h/templ"
)
	`, pkgPath)
}

func getPartialPageBoostFnStr(depType string) string {
	return fmt.Sprintf(`
func getPartialPageBoostFn(partialPageFn func(w http.ResponseWriter, r *http.Request, dep %s, buffer *bytes.Buffer)) func(w http.ResponseWriter, r *http.Request, dep %s, buffer *bytes.Buffer) {
	return func(w http.ResponseWriter, r *http.Request, dep %s, buffer *bytes.Buffer) {
		partialPageFn(w, r, dep, buffer)
		setBoostHeaders(w)
	}
}
	`, depType, depType, depType)
}

func getDynamicPageClosureStr(depType string) string {
	return fmt.Sprintf(`
func getDynamicPageClosure(page PageProps, index IndexProps) (func(w http.ResponseWriter, r *http.Request, dep %s, buffer *bytes.Buffer), error) {

	pageFn := userFunctionWrapper(page.Handler, page.ParamType)
	if pageFn == nil {
		return nil, errors.New("invalid handlerParams")
	}

	mData := initPageMetadataVar(append(index.Metadata, page.Metadata...))

	return func(w http.ResponseWriter, r *http.Request, dep %s, buffer *bytes.Buffer) {
			buffer.Write(mData.Bytes())
			err := pageFn(w, r, dep).Render(r.Context(), buffer)
			if err != nil {
				//set some error stuff
			}
		},
		nil
}
`, depType, depType)
}

// func getStaticPageClosureStr(depType string) string {
// 	return fmt.Sprintf(`
// func getStaticPageClosure(page PageProps) (func(w http.ResponseWriter, r *http.Request, dep %s, buffer *bytes.Buffer), error) {

// 	pageDir := filepath.Clean(filepath.Join(HTML_OUT_DIR, page.Path, PAGE_BODY_OUT_FILE))

// 	return func(w http.ResponseWriter, r *http.Request, dep %s, buffer *bytes.Buffer) {

// 			pageTpl, err := template.ParseFiles(pageDir)
// 			if err != nil {
// 				panic(fmt.Errorf("Error parsing pre-rendered %s from path: %s\n%v", PAGE_BODY_OUT_FILE, pageDir, err))
// 			}

// 			pageTpl.Execute(buffer, nil)

// 		},
// 		nil
// }
// `, depType)
// }

func getStaticPageClosureStr(depType string) string {
	return `
func getStaticPageClosure(page PageProps) (func(http.ResponseWriter, *http.Request, ` + depType + `, *bytes.Buffer), error) {

	pageDir := filepath.Clean(filepath.Join(HTML_OUT_DIR, page.Path, PAGE_BODY_OUT_FILE_W_METADATA))

	return func(w http.ResponseWriter, r *http.Request, def ` + depType + `, buffer *bytes.Buffer) {

			pageTpl, err := template.ParseFiles(pageDir)
			if err != nil {
				panic(fmt.Errorf("Error parsing pre-rendered %s from path: %s\n%v", PAGE_BODY_OUT_FILE_W_METADATA, pageDir, err))
			}

			pageTpl.Execute(buffer, nil)

		},
		nil
}		
`
}

func getDyamicRouteClosureStr(depType string) string {
	return `			
func getDynamicRouteClosure(route RouteProps) (func(http.ResponseWriter, *http.Request,` + depType + `, *bytes.Buffer), error) {

	routeFn := userFunctionWrapper(route.Handler, route.ParamType)
	if routeFn == nil {
		return nil, errors.New("invalid handlerParams")
	}

	return func(w http.ResponseWriter, r *http.Request, dep ` + depType + `, buffer *bytes.Buffer) {
			err := routeFn(w, r, dep).Render(r.Context(), buffer)
			if err != nil {
				//set some error stuff
			}
		},
		nil

}
`
}

func getStaticRouteClosureStr(depType string) string {
	return `			
func getStaticRouteClosure(route RouteProps) (func(http.ResponseWriter, *http.Request,` + depType + `, *bytes.Buffer), error) {

	pageDir := filepath.Clean(filepath.Join(HTML_OUT_DIR, route.Path, ROUTE_OUT_FILE))

	return func(w http.ResponseWriter, r *http.Request, dep ` + depType + `, buffer *bytes.Buffer) {

			pageTpl, err := template.ParseFiles(pageDir)
			if err != nil {
				panic(fmt.Errorf("Error parsing pre-rendered %s from path: %s\n%v", ROUTE_OUT_FILE, pageDir, err))
			}

			pageTpl.Execute(buffer, nil)

		},
		nil
}
`
}

func getStaticFullPageClosureStr(depType string) string {
	return `
func getStaticFullPageClosure(page PageProps, index IndexProps, indexPath string) (func(http.ResponseWriter, *http.Request, ` + depType + `, *bytes.Buffer), error) {

	fullPageDir := filepath.Clean(filepath.Join(HTML_OUT_DIR, page.Path, PAGE_OUT_FILE))
	pageDir := filepath.Clean(filepath.Join(HTML_OUT_DIR, page.Path, PAGE_BODY_OUT_FILE))

	switch index.HandleType {
	case IndexHandle:
		indexFn := userFunctionWrapper(index.Handler, index.ParamType)
		if indexFn == nil {
			return nil, errors.New("invalid handlerParams")
		}

		meta := convertStringListToBytesBuffer(append(index.Metadata, page.Metadata...))

		return func(w http.ResponseWriter, r *http.Request, dep ` + depType + `, buffer *bytes.Buffer) {

			pageTpl, err := template.ParseFiles(pageDir)
			if err != nil {
				panic(fmt.Errorf("Error parsing pre-rendered %s from path: %s\n%v", PAGE_BODY_OUT_FILE, pageDir, err))
			}

			err = indexFn(w, r, dep).Render(templ.WithChildren(r.Context(), templ.FromGoHTML(pageTpl, nil)), buffer)
			if err != nil {
				//set some error stuff
			}

			addMetadataIntoBuffer(buffer, meta)

		}, nil

	case IndexRender:
		return func(w http.ResponseWriter, r *http.Request, dep ` + depType + `, buffer *bytes.Buffer) {
			fullPageTpl, err := template.ParseFiles(fullPageDir)
			if err != nil {
				panic(fmt.Errorf("Error parsing pre-rendered %s from path: %s\n%v", PAGE_OUT_FILE, pageDir, err))
			}

			fullPageTpl.Execute(buffer, nil)
		}, nil
	}

	return nil, errors.New(fmt.Sprintf("something"))
}		
`
}

func getDynamicFullPageClosureStr(depType string) string {
	return `
func getDynamicFullPageClosure(page PageProps, index IndexProps, indexPath string) (func(http.ResponseWriter, *http.Request,` + depType + `, *bytes.Buffer), error) {

	pageFn := userFunctionWrapper(page.Handler, page.ParamType)
	if pageFn == nil {
		return nil, errors.New("invalid handlerParams")
	}

	meta := convertStringListToBytesBuffer(append(index.Metadata, page.Metadata...))

	switch index.HandleType {
	case IndexHandle:
		indexFn := userFunctionWrapper(index.Handler, index.ParamType)
		if indexFn == nil {
			return nil, errors.New("invalid handlerParams")
		}

		return func(w http.ResponseWriter, r *http.Request, dep ` + depType + `, buffer *bytes.Buffer) {
			err := indexFn(w, r, dep).Render(templ.WithChildren(r.Context(), pageFn(w, r, dep)), buffer)
			if err != nil {
				//set some error stuff
			}

			addMetadataIntoBuffer(buffer, meta)

		}, nil

	case IndexRender:

		dir := filepath.Clean(filepath.Join(HTML_OUT_DIR, indexPath, INDEX_OUT_FILE))

		return func(w http.ResponseWriter, r *http.Request, dep ` + depType + `, buffer *bytes.Buffer) {

			indexTpl, err := template.ParseFiles(dir)
			if err != nil {
				panic(fmt.Errorf("Error parsing index.html from path: %s\n%v", dir, err))
			}

			pageTpl, err := templ.ToGoHTML(r.Context(), pageFn(w, r, dep))

			if err != nil {
				panic(fmt.Errorf("Error converting page.go output from path: %s to template.HTML\n%v", page.Path, err))
			}

			_, err = indexTpl.New("page").Parse(string(pageTpl))

			if err != nil {
				panic(fmt.Errorf("Error converting page.go output from path: %s to template.HTML\n%v", page.Path, err))
			}

			err = indexTpl.Execute(buffer, nil)

			if err != nil {
				panic(fmt.Errorf("Error executing template \n%v", err))
			}

			addMetadataIntoBuffer(buffer, meta)

		}, nil
	}

	return nil, errors.New(fmt.Sprintf("something"))
}
`
}

func getUserFunctionWrapperStr(depType string) string {
	return fmt.Sprintf(`
func userFunctionWrapper(fn interface{}, paramType ParamType) func(http.ResponseWriter, *http.Request, %s) templ.Component {
	switch paramType {
	case def:
		setFn := fn.(func() templ.Component)
		return func(w http.ResponseWriter, r *http.Request, dep %s) templ.Component {
			return setFn()
		}
	case dep:
		setFn := fn.(func(%s) templ.Component)
		return func(w http.ResponseWriter, r *http.Request, dep %s) templ.Component {
			return setFn(dep)
		}
	case resReq:
		setFn := fn.(func(http.ResponseWriter, *http.Request) templ.Component)
		return func(w http.ResponseWriter, r *http.Request, dep %s) templ.Component {
			return setFn(w, r)
		}
	case resReqDep:
		setFn := fn.(func(http.ResponseWriter, *http.Request, %s) templ.Component)
		return func(w http.ResponseWriter, r *http.Request, dep %s) templ.Component {
			return setFn(w, r, dep)
		}
	default:
		return nil
	}
}		
`, depType, depType, depType, depType, depType, depType, depType)
}

func executeAppropriateFnStr(depType string) string {
	return fmt.Sprintf(`			
func executeAppropriateFn(w http.ResponseWriter, r *http.Request, dep %s, buffer *bytes.Buffer, page func(w http.ResponseWriter, r *http.Request, dep %s, buffer *bytes.Buffer), boostPage func(w http.ResponseWriter, r *http.Request, dep %s, buffer *bytes.Buffer), index func(w http.ResponseWriter, r *http.Request, dep %s, buffer *bytes.Buffer), boostIndex func(w http.ResponseWriter, r *http.Request, dep %s, buffer *bytes.Buffer)) {
	requestType := determineRequest(r)
	switch requestType {
	case ErrorRequest:
		// handle Error
	case HxGet_Page:
		page(w, r, dep, buffer)
	case HxBoost_Page:
		boostPage(w, r, dep, buffer)
	case HxGet_Index:
		index(w, r, dep, buffer)
	case HxBoost_Index, NormalRequest:
		boostIndex(w, r, dep, buffer)
	}
}
`, depType, depType, depType, depType, depType)
}
